$NetBSD$

--- source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp.orig	2019-06-05 01:49:06.000000000 +0000
+++ source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp
@@ -16,6 +16,7 @@
 #include "lldb/Symbol/UnwindPlan.h"
 #include "lldb/Target/RegisterContext.h"
 #include "lldb/Target/UnwindAssembly.h"
+#include "lldb/Utility/Log.h"
 
 using namespace lldb_private;
 using namespace lldb;
@@ -61,6 +62,7 @@ void x86AssemblyInspectionEngine::Initia
     m_machine_sp_regnum = k_machine_esp;
     m_machine_fp_regnum = k_machine_ebp;
     m_machine_alt_fp_regnum = k_machine_ebx;
+    m_machine_cx_regnum = k_machine_ecx;
     m_wordsize = 4;
 
     struct lldb_reg_info reginfo;
@@ -142,7 +144,8 @@ void x86AssemblyInspectionEngine::Initia
     m_lldb_alt_fp_regnum = lldb_regno;
   if (machine_regno_to_lldb_regno(m_machine_ip_regnum, lldb_regno))
     m_lldb_ip_regnum = lldb_regno;
-
+  if (machine_regno_to_lldb_regno(m_machine_cx_regnum, lldb_regno))
+    m_lldb_cx_regnum = lldb_regno;
   m_register_map_initialized = true;
 }
 
@@ -166,6 +169,7 @@ void x86AssemblyInspectionEngine::Initia
     m_machine_sp_regnum = k_machine_esp;
     m_machine_fp_regnum = k_machine_ebp;
     m_machine_alt_fp_regnum = k_machine_ebx;
+    m_machine_cx_regnum = k_machine_ecx;
     m_wordsize = 4;
 
     struct lldb_reg_info reginfo;
@@ -250,6 +254,8 @@ void x86AssemblyInspectionEngine::Initia
     m_lldb_alt_fp_regnum = lldb_regno;
   if (machine_regno_to_lldb_regno(m_machine_ip_regnum, lldb_regno))
     m_lldb_ip_regnum = lldb_regno;
+  if (machine_regno_to_lldb_regno(m_machine_ip_regnum, lldb_regno))
+    m_lldb_ip_regnum = lldb_regno;
 
   m_register_map_initialized = true;
 }
@@ -346,6 +352,14 @@ bool x86AssemblyInspectionEngine::push_e
   return false;
 }
 
+// pushl -0x4(%ecx)
+// 32-bit only, special case of the above
+// This is used by the main() prologue generated by gcc.
+bool x86AssemblyInspectionEngine::push_extended_ecx_pattern_p() {
+  uint8_t *p = m_cur_insn;
+  return (p[0] == 0xff && p[1] == 0x71 && p[2] == 0xfc);
+}
+
 // instructions only valid in 32-bit mode:
 // 0x0e - push cs
 // 0x16 - push ss
@@ -545,6 +559,30 @@ bool x86AssemblyInspectionEngine::lea_rb
   return false;
 }
 
+// lea 0x4(%esp), %ecx
+// (32-bit variant only, 8-bit displacement)
+bool x86AssemblyInspectionEngine::lea_esp_ecx_pattern_p(int &amount) {
+  uint8_t *p = m_cur_insn;
+  if (m_wordsize == 8)
+    return false;
+
+  // Check opcode
+  if (*p++ != 0x8d)
+    return false;
+
+  // scaled index byte
+  if (p[0] == 0x4c && p[1] == 0x24) {
+    amount = (int8_t)p[2];
+
+    if (amount != 4)
+      return false;
+
+    return true;
+  }
+
+  return false;
+}
+
 // and -0xfffffff0, %esp
 // (32-bit and 64-bit variants, 8-bit and 32-bit displacement)
 bool x86AssemblyInspectionEngine::and_rsp_pattern_p() {
@@ -917,6 +955,10 @@ bool x86AssemblyInspectionEngine::GetNon
     UnwindPlan &unwind_plan) {
   unwind_plan.Clear();
 
+  Log *log(GetLogIfAllCategoriesSet(LIBLLDB_LOG_UNWIND));
+  if (log && log->GetVerbose())
+    log->Printf("parsing assembly %p", &unwind_plan);
+
   if (data == nullptr || size == 0)
     return false;
 
@@ -970,6 +1012,9 @@ bool x86AssemblyInspectionEngine::GetNon
   bool prologue_completed_is_aligned;
   std::vector<bool> prologue_completed_saved_registers;
 
+  bool first_insn = true;
+  bool main_stack_align = false;
+
   while (current_func_text_offset < size) {
     int stack_offset, insn_len;
     int machine_regno;   // register numbers masked directly out of instructions
@@ -991,7 +1036,29 @@ bool x86AssemblyInspectionEngine::GetNon
     auto &afa_value = row->GetAFAValue();
     auto fa_value_ptr = is_aligned ? &afa_value : &cfa_value;
 
-    if (mov_rsp_rbp_pattern_p()) {
+    if (first_insn && lea_esp_ecx_pattern_p(stack_offset)) {
+      cfa_value.SetIsRegisterPlusOffset(m_lldb_cx_regnum, 0);
+      fa_value_ptr = &cfa_value;
+      is_aligned = false;
+      main_stack_align = true;
+      row_updated = true;
+    }
+
+    else if (main_stack_align && push_extended_ecx_pattern_p()) {
+      UnwindPlan::Row::RegisterLocation regloc;
+      // aligned stack pointer value before the push is AFA value
+      regloc.SetIsAFAPlusOffset(0);
+      row->SetRegisterInfo(m_lldb_sp_regnum, regloc);
+
+      // saved instruction pointer can be found at AFA - wordsize.
+      current_sp_bytes_offset_from_fa = m_wordsize;
+      regloc.SetAtAFAPlusOffset(-current_sp_bytes_offset_from_fa);
+      row->SetRegisterInfo(m_lldb_ip_regnum, regloc);
+
+      row_updated = true;
+    }
+
+    else if (mov_rsp_rbp_pattern_p()) {
       if (fa_value_ptr->GetRegisterNumber() == m_lldb_sp_regnum) {
         fa_value_ptr->SetIsRegisterPlusOffset(
             m_lldb_fp_regnum, fa_value_ptr->GetOffset());
@@ -1071,6 +1138,13 @@ bool x86AssemblyInspectionEngine::GetNon
         saved_registers[machine_regno] = true;
         row_updated = true;
       }
+
+      // last part of i386 main() function prologue, push %ecx
+      else if (main_stack_align && machine_regno == k_machine_ecx) {
+        cfa_value.SetUnspecified();
+        main_stack_align = false;
+        row_updated = true;
+      }
     }
 
     else if (pop_reg_p(machine_regno)) {
@@ -1188,7 +1262,7 @@ bool x86AssemblyInspectionEngine::GetNon
     }
 
     else if (push_extended_pattern_p() || push_imm_pattern_p() ||
-             push_misc_reg_p()) {
+             push_misc_reg_p() && !row_updated) {
       current_sp_bytes_offset_from_fa += m_wordsize;
       if (fa_value_ptr->GetRegisterNumber() == m_lldb_sp_regnum) {
         fa_value_ptr->SetOffset(current_sp_bytes_offset_from_fa);
@@ -1323,6 +1397,7 @@ bool x86AssemblyInspectionEngine::GetNon
 
     m_cur_insn = m_cur_insn + insn_len;
     current_func_text_offset += insn_len;
+    first_insn = false;
   }
 
   unwind_plan.SetSourceName("assembly insn profiling");
